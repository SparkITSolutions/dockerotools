#!/usr/bin/env python3

from Crypto.Cipher import AES
from hashlib import pbkdf2_hmac
from zipfile import ZipFile
import os
import re
import sys
import shutil
import subprocess
import zlib
import tempfile

variables = {}

REGEX_INITIAL_STRING_ASSIGNMENT = re.compile(b'\s+(.*?) = \"(.*)\";', re.MULTILINE)
REGEX_STRINGBUILDER = re.compile(b'new StringBuilder\(\)\.(.*)\.toString\(\);')
REGEX_BL_STAGE2 = re.compile(b'decryptObject\(.*?{ { "(.+)" }, .*? "(.+)", "(.+)" }\);')

PROCYON_CMD = "java -jar /opt/decoders/utils/java/procyon-decompiler-0.5.30.jar"
KRAKATAU_CMD = "python2.7 /opt/decoders/utils/Krakatau/decompile.py -skip -path /opt/decoders/utils/java/rt.jar -out"
FNULL = open(os.devnull, "w")

MAPPARSER_PATH = "/opt/decoders/utils/java/"
MAPPARSER_CMD = "java LinkedHashMapParser"

TEMP_FOLDER = None
BINARY_MAP = {}

class Entry:
    def __init__(self):
        self.enckey = []
        self.mapkey = ""
        self.file = ""
    
    def parse(self, line):
        t = line.split(b"||")
        print(line)
        self.mapkey = t[0].decode("utf-8")
        self.enckey = t[1].decode("utf-8").split(",")
        self.file = t[2]

        #cleanup mapkey
        if self.mapkey.startswith("obfuscated/"):
            self.mapkey = self.mapkey[11:]

def work(path):

    setup()
    shutil.copy(path, TEMP_FOLDER + "/sample.jar")
    decompileKrakatau()
    readBinaryMap(TEMP_FOLDER + "/sample.jar")

    buffers = read_all_java_files(TEMP_FOLDER + "/decompiled")

    # get all initial string assignments
    for buf in buffers:
        res = work_on_buffers(buf, REGEX_INITIAL_STRING_ASSIGNMENT)
        if not res:
            continue
        for i in res:
            variables[i[0].decode("ascii")] = i[1].decode("ascii")
    
    #for k,v in variables.items():
    #    print("{} : {}".format(k, v))

    # find stringbuilders
    strings = []
    for buf in buffers:
        res = work_on_buffers(buf, REGEX_STRINGBUILDER)
        if not res:
            continue
        for i in res:
            r = get_append_list(i)
            s = ""
            for t in r:
                s += variables[t] 
            strings.append(s)

    possible_keys = []
    for s in strings:
        if len(s) == 16:
            possible_keys.append(s)

    if len(possible_keys) != 2:
        print("[+] Possible keys: {}".format(possible_keys))
        die("PANIC Too many / few possible keys! Dying...")

    # decrypt stage 2 of bootloader
    read_all_class_files(TEMP_FOLDER + "/sample.jar")
    decrypted_buffers = decrypt_all_files(possible_keys)
    decrypted_bl_stage_2 = find_serialized_class_file(decrypted_buffers)
    if not decrypted_bl_stage_2:
        # try again with swapped key/salt
        decrypted_buffers = decrypt_all_files(possible_keys[::-1])
        decrypted_bl_stage_2 = find_serialized_class_file(decrypted_buffers)
        if not decrypted_bl_stage_2:
            # now we can die
            die("PANIC No second stage for bootloader found in decrypted buffers. Dying...")

    # decompile and parse stage 2 of bootloader
    setup() # create tempdir

    with open(TEMP_FOLDER + "/BLStage2.class", "wb") as f:
        f.write(decrypted_bl_stage_2)   

    decompiled_bl_stage_2 = decompile_class(TEMP_FOLDER + "/BLStage2.class")
    res = work_on_buffers(decompiled_bl_stage_2, REGEX_BL_STAGE2)
    if not res:
        die("PANIC Couldn't match on regex in bootloader stage 2! Dying...")
    bl_stage2_data = res[0]
    res = decrypt_file(BINARY_MAP[bl_stage2_data[0].decode("ascii")], [bl_stage2_data[2].decode("ascii"), bl_stage2_data[1].decode("ascii")])
    if res[0:4] != b"\xac\xed\00\x05":
            res = decrypt_file(BINARY_MAP[bl_stage2_data[0].decode("ascii")], [bl_stage2_data[1].decode("ascii"), bl_stage2_data[2].decode("ascii")])

    if res[0:4] != b"\xac\xed\00\x05":
        die("PANIC Couldn't decrypt hash map! Dying...")

    # write decrypted file to disk
    with open(TEMP_FOLDER + "/hashmap.bin", "wb") as f:
        f.write(res)

    parsedHashMap = parseLinkedHashMap(TEMP_FOLDER + "/hashmap.bin")
    hashmap = {}

    for l in parsedHashMap.split(b"\n"):
        line = l.strip()
        if len(line) < 1:
            continue
        e = Entry()
        e.parse(line)
        hashmap[e.mapkey] = e

    #print(hashmap)
    decryptedHashMap = decryptHashMapFiles(hashmap)

    newZip = ZipFile(path + ".unpacked.jar", "w")
    for k, v in decryptedHashMap.items():
        if len(v) == 0:
            continue
        newZip.writestr(str(k), v)
    newZip.close()
    print("[+] unpacked file, written to {}".format(path + ".unpacked.jar"))

    cleanup()

def decryptHashMapFiles(hashmap):
    ret = {}

    for k, v in hashmap.items():
        # read all files needed
        buf = BINARY_MAP[v.file.decode("ascii")]
        # print(v.enckey)
        # print(v.mapkey)
        # print(v.file)
        # print(buf[0:16])
        #c = AES.new(v.enckey, AES.MODE_ECB)
        #dec = c.decrypt(buf)
        dec = decrypt_file(buf, v.enckey[::-1])
        # print(dec[0:16])
        #decomp = zlib.decompress(dec, zlib.MAX_WBITS|32)
        #ret[k] = decomp
        ret[k] = dec
    return ret


def parseLinkedHashMap(path):
    wd = os.getcwd()
    os.chdir(MAPPARSER_PATH)

    args = MAPPARSER_CMD.split(" ")
    args.append(path)
    p = subprocess.Popen(args, stdout=subprocess.PIPE)
    out, err = p.communicate()

    os.chdir(wd)
    return out

def readBinaryMap(path):
    zf = ZipFile(path, "r")
    for file in zf.infolist():
        BINARY_MAP[file.filename] = zf.read(file)
        #print("[+] added file {} to BINARY_MAP".format(file.filename))

def decompileKrakatau():
    args = KRAKATAU_CMD.split(" ")
    args.append(TEMP_FOLDER + "/decompiled")
    args.append(TEMP_FOLDER + "/sample.jar")
    subprocess.call(args, stdout=FNULL, stderr=subprocess.STDOUT)

def decompile_class(path):
    args = PROCYON_CMD.split(" ")
    args.append(path)
    p = subprocess.Popen(args, stdout=subprocess.PIPE)
    out, err = p.communicate()
    return out

def find_serialized_class_file(buffers):
    for buf in buffers:
        if buf[0:4] == b"\xca\xfe\xba\xbe":
            return buf
    return None

def decrypt_file(buffer, keys):
    key = pbkdf2_hmac(
        hash_name = "sha1",
        password = bytes(keys[1], "ascii"),
        salt = bytes(keys[0], "ascii"),
        iterations = 10000,
        dklen = 16)
    c = AES.new(key, AES.MODE_ECB)
    try:
        d = c.decrypt(buffer)
    except:
        return None
    return d

def decrypt_all_files(keys):
    res = []

    for k, buf in BINARY_MAP.items():
        r = decrypt_file(buf, keys)
        if not r:
            continue
        res.append(r)
    return res


def get_append_list(line):
    tokens = line.split(b"append(")
    tokens = tokens[1:]
    list = []
    for tok in tokens:
        tok = tok.rstrip(b".").rstrip(b")").decode("ascii")
        list.append(tok)
    return list

def work_on_buffers(buf, regex):
    rex = regex.findall(buf)
    return rex

def read_all_java_files(path):
    return read_all_files(path, ".java")

def read_all_class_files(path):
    return read_all_files(path, ".class")

def write_buffers_to_temp_folders(buffers):
    d = tempfile.mkdtemp()
    i = 0
    for buf in buffers:
        with open(d + "/{}".format(i), "wb") as f:
            f.write(buf)
        i += 1
    print("Wrote files to {}".format(d))

def read_all_files(path, ext):
    read_files = []
    for root, subdirs, files in os.walk(path):
        for fname in files:
            if fname.endswith(ext):
                fpath = os.path.join(root, fname)
                read_files.append(fpath)
    

    buffers = []
    for file in read_files:
        with open(file, "rb") as f:
            b = f.read()
        buffers.append(b)
    return buffers

def setup():
    global TEMP_FOLDER
    TEMP_FOLDER = tempfile.mkdtemp()

def cleanup():
    global TEMP_FOLDER
    if TEMP_FOLDER:
        shutil.rmtree(TEMP_FOLDER)
        TEMP_FOLDER = None

def die(s):
    print("[!] {}".format(s))
    cleanup()
    sys.exit(-1)

if __name__=="__main__":
    work(sys.argv[1])
    cleanup()